(export cond*)
(import (for-syntax :std/sugar
		    :std/stxutil))

;; cond for multiple choices
(defrules cond* (else =>)
  ((cond* (else result0 results ...))
   (list (begin result0 results ...)))
  ((cond* (test => result))
   (let ((t test))
     (if t (list (result t)) (list))))
  ((cond* (test => result) clause0 clauses ...)
   (let ((t test)
	 (r (cond* clause0 clauses ...)))
     (if t (cons (result t) r) r)))
  ((cond* (test))
   (let ((t test))
     (if t (list test) (list))))
  ((cond* (test) clause0 clauses ...)
   (let ((t test)
	 (r (cond* clause0 clauses ...)))
     (if t (cons t r) r)))
  ((cond* (test result0 results ...))
   (if test (list (begin result0 results ...)) (list)))
  ((cond* (test result0 results ...)
	  clause0 clauses ...)
   (let ((r (cond* clause0 clauses ...)))
     (if test
       (cons (begin result0 results ...) r)
       r))))

;; (cond* (else 1))
;; (cond* (1 => (lambda (x) x)))
;; (cond* (#f => (lambda (x) x)))
;; (cond* (666 => (lambda (x) (list 'the-doom-is-here x)))
;;        (#f 'nevermind)
;;        ((eq? 2 2) 'second-sym)
;;        ((eq? 1 1) 'first-sym)
;;        (2)
;;        (else 1)) ;; => ((the-doom-is-here 666) second-sym first-sym 2 1)
